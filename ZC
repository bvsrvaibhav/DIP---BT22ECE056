module Piecewise_Parabolic_Interpolator #(
    parameter WIDTH      = 16,
    parameter ERR_WIDTH  = 32
)(
    input  wire clk,
    input  wire rst,
    input  wire en,
    input  wire signed [15:0] mu_test,
    input  wire signed [WIDTH-1:0] x_n3,
    input  wire signed [WIDTH-1:0] x_n2,
    input  wire signed [WIDTH-1:0] x_n1,
    input  wire signed [WIDTH-1:0] x_n,
    output reg  signed [WIDTH-1:0] x_interp,
    output wire signed [ERR_WIDTH-1:0] zc_error,
    output wire signed [WIDTH-1:0] stuffed_data_out,
    output wire stuffed_valid_out,
    output wire signed [ERR_WIDTH-1:0] control_signal,
    output wire signed [10:0] mu_dbg,

    // New outputs for actual symbol-timing synchronized output
    output wire signed [WIDTH-1:0] final_output_data,
    //output wire signed [WIDTH-1:0] Symbol_sync_out,
    output wire                   final_output_valid
);

    localparam signed [31:0] ONE_32 = 32'sh0000_8000;
    localparam signed [31:0] TWO_32 = 32'sh0001_0000;
    reg signed [WIDTH-1:0] Symbol_sync_out;
    wire signed [10:0] mu_internal;
    wire underflow;
    wire signed [31:0] mu_fp_32     = { {16{mu_test[15]}}, mu_test };
    wire signed [31:0] mu_minus_1   = mu_fp_32 - ONE_32;
    wire signed [31:0] mu_minus_2   = mu_fp_32 - TWO_32;
    wire signed [63:0] L0_full = mu_fp_32 * mu_minus_1;
    wire signed [63:0] L1_full = -(mu_fp_32 * mu_minus_2);
    wire signed [63:0] L2_full = mu_minus_1 * mu_minus_2;
    wire signed [63:0] L0 = L0_full >>> 1;
    wire signed [63:0] L2 = L2_full >>> 1;
    wire signed [47:0] x_n2_48 = {{32{x_n2[15]}}, x_n2};
    wire signed [47:0] x_n1_48 = {{32{x_n1[15]}}, x_n1};
    wire signed [47:0] x_n_48  = {{32{x_n[15]}}, x_n};
    wire signed [63:0] term0 = L0 * x_n2_48;
    wire signed [63:0] term1 = L1_full * x_n1_48;
    wire signed [63:0] term2 = L2 * x_n_48;
    wire signed [63:0] sum_full = term0 + term1 + term2;
    always @(posedge clk) begin
        if (rst) x_interp <= 0;
        else if (en) x_interp <= sum_full >>> 30;
    end
    // Zero-crossing TED
    zcted2 #(
        .DATA_WIDTH(WIDTH),
        .ERR_WIDTH(ERR_WIDTH)
    ) u_zcted2 (
        .clk      (clk),
        .rst      (rst),
        .en       (en),
        .x_in    (x_interp),
       // .x_mid    (x_n1),
        .error (zc_error)
    );
    upsampler_by_2 #(
        .DATA_WIDTH(WIDTH)
    ) u_zero_stuffer (
        .clk       (clk),
        .rst       (rst),
        .data    (zc_error[WIDTH - 1: 0]),
       // .valid_in   (en),
        .data_out   (stuffed_data_out)
       // .valid_out  (stuffed_valid_out)
    );
    PI_Loop_Filter_ConstGain #(
        .WIDTH(WIDTH),
        .OUT_WIDTH(ERR_WIDTH)
    ) u_pi_loop (
        .clk        (clk),
        .rst        (rst),
        .error_in   (stuffed_data_out),
        .control_out(control_signal)
    );
    NCO #(
        .WIDTH(11)
    ) u_nco (
        .clk       (clk),
        .reset     (rst),
        .enb       (en),
        .Delta     (control_signal[10:0]),
        .mu        (mu_internal),
        .Underflow (underflow)
    );
    wire signed [10:0] mu_updated = mu_internal;
//    update_mu #(
//        .WIDTH(11)
//    ) u_update_mu (
//        .clk      (clk),
//        .rst      (rst),
//        .underflow(underflow),
//        .mu_in    (mu_internal),
//       // .v_n      (control_signal[10:0] >>> 1),  // Example: half Delta
//        .mu_out   (mu_updated)
//    );

    assign mu_dbg = mu_updated <<< 7;

    // === Output actual synchronized symbol on underflow ===
    reg signed [WIDTH-1:0] x_out;
    reg                    x_out_valid;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            x_out       <= 0;
            x_out_valid <= 0;
        end else if (underflow) begin
            x_out       <= x_interp;
            x_out_valid <= 1;
        end else begin
            x_out_valid <= 0;
        end
    end

    assign final_output_data  = x_out;
    assign final_output_valid = x_out_valid;
    
    always @(posedge clk or posedge rst)begin
       if (underflow) begin
         
            Symbol_sync_out <= final_output_data;
            end else begin
               
               Symbol_sync_out <=0;
               end
    end
integer f_valid_log;

initial begin
  f_valid_log = $fopen("C:/Users/test/Downloads/SSS/imag.txt", "w");
  if (f_valid_log == 0) begin
    $display("ERROR opening log file.");
    $finish;
  end
end

always @(posedge clk) begin
  if (!rst) begin
    $fwrite(f_valid_log, "%h\n",final_output_data);  // <-- Only the value
    $fflush(f_valid_log);
  end
end
endmodule
/////////////////////////////////////////////////////////////////////////


`timescale 1ns / 1ps

module zcted2 #(
    parameter DATA_WIDTH = 16,
    parameter ERR_WIDTH  = 32
)(
    input  wire                         clk,
    input  wire                         rst,
    input  wire                         en,
    input  wire signed [DATA_WIDTH-1:0] x_in,   // current input sample
output reg  signed [ERR_WIDTH-1:0]  error    // output timing error
); 

    // Delay elements
    reg signed [DATA_WIDTH-1:0] x_n1, x_n2;

    // Internal wires
    wire signed [DATA_WIDTH-1:0] s1, s2;
    wire signed [DATA_WIDTH:0]   diff_signs;
    wire signed [2*DATA_WIDTH-1:0] prod;

    // Sign function (returns -1, 0, or 1)
    function signed [DATA_WIDTH-1:0] sign_func;
        input signed [DATA_WIDTH-1:0] val;
        begin
            if (val > 0)
                sign_func = 16'sd1;
            else if (val < 0)
                sign_func = -16'sd1;
            else
                sign_func = 16'sd0;
        end
    endfunction

    // Compute signs of input and delayed input
    assign s1 = sign_func(x_in);
    assign s2 = sign_func(x_n2);
    
    // Difference of signs
    assign diff_signs = s1 - s2;

    // Multiply diff_signs with x_n1 (middle sample)
    assign prod = diff_signs * x_n1;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            x_n1  <= 0;
            x_n2  <= 0;
            error <= 0;
        end else if (en) begin
            x_n2  <= x_n1;
            x_n1  <= x_in;
            error <= prod;
        end
    end

endmodule




/////////////////////////////////////////////////////////////

`timescale 1ns / 1ps

module upsampler_by_2 #(
    parameter DATA_WIDTH = 16
)(
    input  wire                   clk,
    input  wire                   rst,
    input  wire signed [DATA_WIDTH-1:0] data,
   
    output reg  signed [DATA_WIDTH-1:0] data_out
);

    // Toggle signal for alternation
    reg toggle;
    reg signed [DATA_WIDTH-1:0] data_reg;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            toggle    <= 1'b0;
            data_out  <= 0;
            data_reg  <= 0;
        end else begin
            if (toggle == 1'b0) begin
                // On even cycles: output the real input sample
                data_reg <= data;
                data_out <= data;
            end else begin
                // On odd cycles: insert 0
                data_out <= 0;
            end
            toggle <= ~toggle; // Alternate every cycle
        end
    end

endmodule


/////////////////////////////////////////////////////////////////////



`timescale 1ns / 1ps

module PI_Loop_Filter_ConstGain #(
    parameter WIDTH = 16,
    parameter OUT_WIDTH = 32
)(
    input wire clk,
    input wire rst,
    input wire signed [WIDTH-1:0] error_in,      // e.g., 16-bit signed Q1.15 error
    output reg signed [OUT_WIDTH-1:0] control_out
);

    // Fixed-point gains in Q1.15 (signed)
    localparam signed [15:0] K1 = 16'shFFAF;   // -81 in decimal = -2.4609e-3
    localparam signed [15:0] K2 = 16'shFFFF;   // -1 in decimal = -8.2030e-6

    // Internal signals
    reg signed [OUT_WIDTH-1:0] integrator;
    wire signed [OUT_WIDTH-1:0] proportional_term;
    wire signed [OUT_WIDTH-1:0] integral_term;

    // Multiply input error with gains (signed * signed)
    assign proportional_term = (error_in * K1);
    assign integral_term     = (error_in * K2);

    // Main PI loop logic
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            integrator  <= 0;
            control_out <= 0;
        end else begin
            integrator  <= integrator + integral_term;
            control_out <= proportional_term + integrator;
        end
    end

endmodule





///////////////////////////////////////////////////////////////



`timescale 1ns / 1ps

module NCO #(
    parameter WIDTH = 11  // sfix11_En10
)(
    input  wire                     clk,
    input  wire                     reset,
    input  wire                     enb,
    input  wire signed [WIDTH-1:0] Delta,     // Loop filter output
    output reg  signed [WIDTH-1:0] mu,        // Interpolation fraction
    output reg                     Underflow  // Strobe for TED
);

    // Internal state
    reg signed [WIDTH-1:0] countReg, muReg;
    reg                    underflowReg;

    wire signed [WIDTH-1:0] countMasked = countReg & 11'b01111111111;
    wire signed [12:0]      counter     = $signed({1'b0, countMasked}) - $signed({1'b0, Delta}) - 13'sd512;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            countReg     <= 0;
            muReg        <= 0;
            underflowReg <= 0;
        end else if (enb) begin
            if (counter < 0) begin
                // Underflow: time to interpolate a new symbol
                Underflow  <= 1;
                mu         <= (countReg & 11'b01111111111) << 2;  // Scale to Q2.9
                countReg   <= counter + 13'sd512;
            end else begin
                // Normal accumulation
                Underflow <= 0;
                mu        <= muReg;
                countReg  <= counter[10:0];  // Wrap/clip logic
            end
            muReg        <= mu;
            underflowReg <= Underflow;
        end
    end

endmodule

//////////////////////////////////////////////////////////////////////////



`timescale 1ns / 1ps

module update_mu #(
    parameter WIDTH = 11  // Q1.10 fixed-point
)(
    input  wire                  clk,
    input  wire                  rst,
    input  wire                  underflow,     // Strobe from NCO
    input  wire signed [WIDTH-1:0] mu_in,       // From NCO
   // input  wire signed [WIDTH-1:0] v_n,         // 0.5 Ãƒ- Delta from loop filter
    output reg  signed [WIDTH-1:0] mu_out      // Updated mu to use in interpolator
);

    // Internal accumulator for fractional delay
    // reg signed [WIDTH-1:0] acc;

    always @(posedge clk or posedge rst) begin
        if (rst) begin
       //     acc     <= 0;
            mu_out  <= 0;
        end else // if (underflow) begin
        //    acc     <= mu_in - v_n;
            mu_out  <= mu_in;
        // end
    end

endmodule




//////





`timescale 1ns / 1ps

module tb_QPSK_Symbol_Timing_Sync_Top;

    parameter DATA_WIDTH   = 16;
    parameter MU_WIDTH     = 10;
    parameter MU_FRAC      = 9;
    parameter COEFF_WIDTH  = 16;
    parameter ACC_WIDTH    = 32;
    parameter MEM_DEPTH    = 16384;

    reg clk = 0;
    reg rst = 1;

    reg signed [DATA_WIDTH-1:0] I_mem [0:MEM_DEPTH-1];
    reg signed [DATA_WIDTH-1:0] Q_mem [0:MEM_DEPTH-1];

    reg signed [DATA_WIDTH-1:0] I_in = 0;
    reg signed [DATA_WIDTH-1:0] Q_in = 0;

    wire signed [DATA_WIDTH-1:0] I_out;
    wire signed [DATA_WIDTH-1:0] Q_out;
    wire                         valid_out;

    integer i;
    integer f_i_log, f_q_log;

  QPSK_Symbol_Timing_Sync_Top #(
        .DATA_WIDTH(DATA_WIDTH),
        .MU_WIDTH(MU_WIDTH),
        .MU_FRAC(MU_FRAC),
        .COEFF_WIDTH(COEFF_WIDTH),
        .ACC_WIDTH(ACC_WIDTH)
    ) dut (
        .clk(clk),
        .rst(rst),
        .I_in(I_in),
        .Q_in(Q_in),
        .I_out(I_out),
        .Q_out(Q_out),
        .valid_out(valid_out)
    );

    // Clock generation: 100 MHz
    always #5 clk = ~clk;

    // Log file open
    initial begin
        f_i_log = $fopen("C:/Internships/NRSC/GTED/I1_log.txt", "w");
        f_q_log = $fopen("C:/Internships/NRSC/GTED/I2_log.txt", "w");

        if (f_i_log == 0 || f_q_log == 0) begin
            $display("ERROR opening output log files.");
            $finish;
        end
    end

    // Header printing flag
    reg header_printed = 0;

    // Output logging on valid_out
    always @(posedge clk) begin
        if (!rst && valid_out) begin
            $fwrite(f_i_log, "%h\n", I_out);
            $fwrite(f_q_log, "%h\n", Q_out);
            $fflush(f_i_log);
            $fflush(f_q_log);

            if (!header_printed) begin
                $display("Time(ns) |   I_in |  Q_in | I_out | Q_out | valid_out | I_interp | Q_interp |   e_k   |  e_k_zs |   v_k   |   mu");
                header_printed = 1;
            end

            if ($time <= 1000) begin
                $display("%8t | %6d | %6d | %6d | %6d |     %1b      | %8d | %8d | %7d | %7d | %7d | %4d",
                    $time,
                    I_in, Q_in,
                    I_out, Q_out,
                    valid_out,
                    dut.interpolator_inst.I_interp,   // Cubic interpolated I
                    dut.interpolator_inst.Q_interp,   // Cubic interpolated Q
                    dut.zcted_inst.e_k,               // TED output (44-bit)
                    dut.zs_inst.e_k_zs,              // TED truncated
                    dut.loop_filter_inst.v_k,
                    dut.nco_update_inst.mu
                );
            end
        end
    end

    // Stimulus
    initial begin
        $readmemh("C:/Internships/NRSC/GTED/I1.txt", I_mem);
        $readmemh("C:/Internships/NRSC/GTED/I2.txt", Q_mem);

        #20 rst = 0;

        for (i = 0; i < MEM_DEPTH; i = i + 1) begin
            @(posedge clk);
            I_in <= I_mem[i];
            Q_in <= Q_mem[i];
        end

        I_in <= 0;
        Q_in <= 0;

        repeat (200) @(posedge clk);

        $fclose(f_i_log);
        $fclose(f_q_log);

        $display("Simulation done. Output files written.");
        $stop;
    end

endmodule






% --- MATLAB Script to Plot I/Q Constellation Diagram ---

clear;
clc;
close all;

% --- Configuration ---
% IMPORTANT: Make sure 'I1_log.txt' and 'I2_log.txt' are uploaded to your
% MATLAB Online Drive, in the same folder as this script.
i_file_path = 'I1_log.txt';
q_file_path = 'I2_log.txt';

% Fixed-point data parameters
DATA_WIDTH = 16;       % 16 bits
Q_FORMAT   = 15;       % Q1.15 format (1 sign bit, 15 fractional bits)

% --- Read I-Data File ---
try
    fid_i = fopen(i_file_path, 'r');
    if fid_i == -1
        error('Could not open I-data file: %s', i_file_path);
    end
    % Read hex data and convert to decimal
    hex_i_data = textscan(fid_i, '%s');
    fclose(fid_i);
    
    % Convert hex (two's complement) to signed decimal
    i_int_data = hex2dec(hex_i_data{1});
    % Handle negative numbers (convert from two's complement)
    is_negative_i = i_int_data >= 2^(DATA_WIDTH - 1);
    i_int_data(is_negative_i) = i_int_data(is_negative_i) - 2^DATA_WIDTH;
    
    % Convert to floating point
    i_data = i_int_data / (2^Q_FORMAT);
    
catch e
    fprintf('Error reading I-file: %s\n', e.message);
    return;
end

% --- Read Q-Data File ---
try
    fid_q = fopen(q_file_path, 'r');
    if fid_q == -1
        error('Could not open Q-data file: %s', q_file_path);
    end
    % Read hex data and convert to decimal
    hex_q_data = textscan(fid_q, '%s');
    fclose(fid_q);
    
    % Convert hex (two's complement) to signed decimal
    q_int_data = hex2dec(hex_q_data{1});
    % Handle negative numbers (convert from two's complement)
    is_negative_q = q_int_data >= 2^(DATA_WIDTH - 1);
    q_int_data(is_negative_q) = q_int_data(is_negative_q) - 2^DATA_WIDTH;
    
    % Convert to floating point
    q_data = q_int_data / (2^Q_FORMAT);
    
catch e
    fprintf('Error reading Q-file: %s\n', e.message);
    return;
end

% --- Plotting ---
% Check if we have data
if isempty(i_data) || isempty(q_data)
    disp('No data read from files. Cannot plot.');
    return;
end

% Ensure I and Q vectors are the same length
min_len = min(length(i_data), length(q_data));
i_data = i_data(1:min_len);
q_data = q_data(1:min_len);

disp(['Plotting ', num2str(min_len), ' I/Q points.']);

% Create the plot
figure;
% Use 'o' for hollow circles
scatter(i_data, q_data, 36, 'o', 'MarkerEdgeColor', [0, 0.4470, 0.7410]);

% --- Style the Plot (like your example) ---
title('Constellation Diagram');
xlabel('In-Phase (I)');
ylabel('Quadrature (Q)');
grid on;
axis equal; % Make X and Y axes have the same scale

% Set axis limits (optional, but good for QPSK)
% Adjust these limits if your plot looks too zoomed in or out
max_val = max(max(abs(i_data)), max(abs(q_data))) * 1.2;
max_val = max(max_val, 0.8); % Set a minimum axis size
axis([-max_val, max_val, -max_val, max_val]);

disp('Plot generated successfully.');
